// Более подробное описание promise

// Promise правильнее всего представить в виде объекта, который имеет 2 основных значения:
// 1) Состояние (ожидание, выполнено успешно, закончилось ошибкой)
// 2) Очередь из функций на выполнение (считай, массив из функций)
// https://disq.us/url?url=https%3A%2F%2Fyoutu.be%2FIh6Q7ka2eSQ%3Ft%3D2369%3A3IGPvu_R-JV5n9BsH0R23F4N97Y&cuid=1192968

//Вот в таком виде можно представить объект promise
const promiseObject = {
    state: 'pending', // либо fullfiled либо rejected
    resolvedQueue: [] //Внутри массива очередь из функций
}

// В следующем примере  создаем объект promise в который далее передаем функции поочередно
// Каждый новый в
const delay = (ms) => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve();
            console.log('resolved');

        }, ms);
    });

}
const promise = delay(2000);
promise.then(() => console.log(11));
promise.then(() => console.log(22));
promise.then(() => console.log(33));

// В следующем же примере применяется так называемый чейнинг, функции передаются связано по принципу метода
// В таком случае выполнение следующей функции из очереди будет обусловлено итогом выполнения предыдущей
    promise
        .then(()=> console.log(44))
        .then(()=> console.log(55))
        .then(()=> console.log(66))
// В предыдущем случае мы добавляли функции одному и тому же промису,
// в данном же примере каждый новый .then создает новый promise, зависящий от результата предыдущего

//На видео по ссылке доступны примеры итд